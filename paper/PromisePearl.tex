\documentclass[12pt, english, letterpaper]{kuthesis}
\usepackage{mathptmx}
\renewcommand{\sfdefault}{lmss}
\renewcommand{\ttdefault}{lmtt}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{geometry}
\geometry{verbose,tmargin=1in,bmargin=1in,lmargin=1in,rmargin=1in}
\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}
\usepackage{color}
\usepackage{babel}
\usepackage{url}
\usepackage{graphicx}
\usepackage{setspace}
\usepackage{esint}
\usepackage[authoryear]{natbib}
\doublespacing
\usepackage[unicode=true,
 bookmarks=true,bookmarksnumbered=false,bookmarksopen=false,
 breaklinks=true,pdfborder={0 0 0},pdfborderstyle={},backref=false,colorlinks=true]
 {hyperref}
\hypersetup{pdftitle={University of Kansas Thesis Template},
 pdfauthor={Anonymous},
 pdfsubject={A Thesis},
 urlcolor={black},citecolor={black},allcolors={black}}



\usepackage{listings}
\usepackage{fancyvrb}

\newcommand{\lit}[1]{\texttt{#1}}

\DefineVerbatimEnvironment{code}{Verbatim}{}
%\newenvironment{code}{\Verbatim}{\endVerbatim}

\title{Promise Land}
\author{Andrei Elliott}

\priorcreds{}

\dept{Electrical Engineering and Computer Science}
\degreetitle{Master of Science}
\papertype{Project Report}

\committee {Matt Moore}{-}{-}{}{}{}{}
\role      {Chair}{}{}{}{}{}{}



\makeatletter
\@printd@testrue
\datedefended{-}
\dateapproved{-}
\makeatother

\begin{document}

\begin{romanpages}
  \maketitle
%  \tableofcontents {}
\end{romanpages}

\section{Introduction}
One widely used model of concurrency is Javascript's Promises.  A promise works in some ways like a lazy value, in that it will at some point contain the result of a computation, but does not stop flow of control in the current thread to compute that value.  Unlike a value with lazy semantics, a promise can immediately begin computation in a separate thread as opposed to waiting for the result to be requested by some other computation.

Promises are composable: using \lit{then} and \lit{catch}, we can chain a promise onto the end of a different one creating a new promise that continues computation after the first has succeeded or failed respectively.

We build a model of promises in Haskell to compare it against other concurrency frameworks.
\section{Motivation}
[Discussion of the adoption of the promises model in Javascript; will have to see what I can find citations for.]

Promise objects are a good candidate for parameterized types: they yield a value upon success or failure, and it would be nice to be able to check statically that these values and the functions that they will be passed to all agree on the types involved.

The operation \lit{then} should ``chain promises together'' by accepting a function that converts a regular value to a promise, then applying it to a promise with that return type by waiting for it to finish before calling the function.  We note that this operation is very similar to \lit{>>=} [give type signature here?], suggesting that promises can be thought of as monads.  (We also note that it is trivial to wrap an arbitrary value into a promise so \lit{return} poses no problem.  In practice, we define a separate constructor for this case to avoid forking off an entire new thread to do no computation and hand back the same result immediately.)

\section{Background}
[HS type signature syntax - mention here that I'm using \lit ? in type signatures I'm discussing as a metavariable, not real syntax?]
[IO monad, do notation]
[forkIO, description of MVar]
[maybe discuss GADTs briefly ?]

[Terminology for discussing promises: states \emph{pending, fulfilled, rejected}; resolve means pending -> fulfilled, reject - pending -> rejected, settle - pending -> <either>; define promise chain; Promises here $\neq$ lazy values, despite terminology clash w/ e.g. Scheme]

\section{Haskell Implementation}

[core bits]
Javascript's \lit{Promise()} constructor builds a new promise object from an `executor' function.  The executor accecpts two callback functions the standard names resolutionFunc and rejectionFunc, one to call in the case of successful resolution and the other for failure.  The executor will, on a success/failure, call resolutionFunc/rejectionFunc, repectively, passing in the value of or reason for the success or failure.  Let's assume we want a promise with type \lit{Promise f p}, i.e. one where success results in a value of type \lit p and failure gives a reason with type \lit f.  To build one, \lit{resolutionFunc} will need to accept a value of type \lit p.  Since calling \lit{resolutionFunc} will settle the promise and therefore have effects elsewhere in the promise chain, its return type will have to be something wrapped in \lit{IO}, so we know \lit{resolutionFunc :: p -> IO ?}.  Similarly, \lit{rejectionFunc} must accept a \lit f, and calling it will also settle the promise, so \lit{rejectionFunc :: f -> IO ?}.  The executor function should accept \lit{resolutionFunc} and \lit{rejectionFunc} as parameters and is expected to end by calling exactly one of them, so we will expect it to have a proper tail call to one of the parameters.  This means its return type matches that of \lit{resolutionFunc} and \lit{rejectionFunc}, i.e. \lit{executor :: (p -> IO ?) -> (p -> IO ?) -> IO ?} and the \lit ?s for the two callbacks should be the same type.  [For now, let's use \lit{()} as \lit ?, so that the callbacks have a return type of \lit{IO ()}, the conventional Haskell type for \lit{IO} actions that have an effect (here, setting the Promise from \lit{Pending} state to one of the settled states) instead of containing a useful value.]  Our function for building a \lit{Promise} object needs to accept a function with the type of \lit{executor} and give back a \lit{Promise} value, which must be contained in \lit{IO} because it has the side effect of running the \lit{executor} in another thread.  It thus has the type \lit{newPromise :: ((p -> IO ()) -> (f -> IO ()) -> IO ()) -> IO (Promise f p)}.  We can represent a \lit{Promise f p} by an \lit{MVar (Either f p)}.  Once the computation for the \lit{Promise} is complete, it can be written to with an \lit{Either f p} value, i.e. \lit{Left reason} for a failure or \lit{Right result} in the case of success.  \lit{newPromise} will also need to fork a thread that will run the executor and set up communication so that the final \lit{Promise} object will be updated with the results once they are available.  In total, we need to: create an \lit{MVar} which we'll call \lit{state}, then fork a thread that calls the executor, passing it callback functions that write the results to \lit{state}, and finally, return \lit{state} as a \lit{Promise} value.
\begin{code}
newPromise :: ((p -> IO ()) -> (f -> IO ()) -> IO ()) -> IO (Promise f p)
newPromise k = do
  state <- newEmptyMVar
  forkIO $ k (putMVar state . Right) (putMVar state . Left)
  return (Pending state)
\end{code}
% $
Since the constructor here is used to create \lit{Promise}s that are in the \emph{pending} state, we'll call it \lit{Pending}.  We could, in principle, use this same constructor to build \lit{Promise} values that we know have already succeeded or failed.  To get a promise that always succeeds with a value of \lit s, say, simply call \lit{newPromise} with an executor that immediately calls \lit{successFunc}, like so:
\begin{code}
newPromise (\ succeed fail -> succeed s)
\end{code}
This is inefficient, though, because it spawns an entire new thread in order to do absolutely nothing with it.  Instead, it is easy enough to define a constructor that marks a value as known to be the result of a sucessful computation (and a parallel one declaring a value to be the known reason for a failed computation).  These correspond to the promise being in the state \emph{fulfilled} or \emph{rejected}, repectively, so we will uses those terms as the names the constructors.  At this point, the \lit{Promise} type has the following form [(in GADT syntax)]:
\begin{code}
data Promise :: * -> * -> * where
  Pending :: MVar (Either f p) -> Promise f p
  Fulfilled :: p -> Promise f p
  Rejected :: f -> Promise f p
\end{code}
[side note: could use \lit{Void} as \lit ? instead of \lit{()} - this would cause the compiler to check that at least one of the callbacks is used - reworked into Token type with non exported constuctor; maybe provide \lit{hangForever :: Token} (or \lit{IO Token})so it can be used but can't be accidental?]


[then and catch]
Now that we can create \lit{Promise} values, the next step is to allow them to chain together.  Javascript's \lit{Promise.then()} is used to set a handler function to run after a promise completes.  Specifically, \lit{p1.then(f)} results in a new promise that will wait for the \lit{Promise} \lit{p1} to complete.  If \lit{p1} succeeds and resolves to a value \lit v, it will then call \lit{f(v)}.  The result of running the callback should be another \lit{Promise}, \lit{p2}; when it settles, the new \lit{Promise} will also settle, to the same state and value.
[Javascript also allows the callback to return a non-\lit{Promise} value, in which case \lit{p1.then(f)} resolves to that value as soon as it's computed.  We won't implement this functionality directly
(allowing differeng argument types would not work in Haskell's type system unless we made separate \lit{then} functions for the two variants).  However, we get to the same result by enclosing the value we would like to return in an always-successful \lit{Promise}.  Once we define a monad instance for \lit{Promise f}, we can even do so by writing \lit{return v} where \lit{v} is the value for the final promise to resolve to, which should look familiar to anyone used to the Javascript syntax!]
In our system in Haskell, \lit{pThen} accepts \lit{pr}, a \lit{Promise f p} along with a callback that expects a value of type \lit p, the type contained in a sucessful \lit{Promise f p}.  \lit{pThen} will return a \lit{Promise} (in \lit{IO} because [blah blah asynchronous], which must have the same failure type as \lit{pr} because if \lit{pr} is Rejected, the result will be as well, with the same value.  The result type can have a different sucess type, though, so it's overall type is \lit{IO (Promise f p')}.  The callback returns a new \lit{Promise} in IO, which must match \lit{pThen}'s return type, so in total
\begin{code}
pThen :: Promise f p
        -> (p -> IO (Promise f p'))
        -> IO (Promise f p')
\end{code}
[implementation without runPromise, for only the Pending, Fulfilled, Rejected constructors.]
\begin{code}
pThen (Pending state) k = do
  result <- readMVar state
  case result of
    Left x -> return $ reject x
    Right x -> k x
pThen (Fulfilled x) k = k x
pThen (Rejected x) k = return $ reject x
\end{code}
      
 [Note that the type signature for \lit{pThen} looks extremely similar to the type \lit{(>>=)} would have if it were to be specialized to \lit{Promise f} (\lit{(>>=) :: Promise f a -> (a -> Promise f b) -> Promise f b}).  The difference is that \lit{pThen} is entangled in the \lit{IO} monad.]
 \lit{Promise.catch()} works the same way as \lit{.then()} except that the handler is set to run only if and when the \lit{Promise} it is being chained to fails, rather then when it succeeds.  Our translation to Haskell, \lit{pCatch}, is very much like \lit{pThen} except that the code for a failed promise and a successful one have swapped places.  Its type is
 \begin{code}
pCatch :: Promise f p
        -> (f -> IO (Promise f' p))
        -> IO (Promise f' p)
\end{code}
which is the same as that for \lit{pThen} except that it operates on the type \lit f, the type of failure cases, instead of \lit p, the type of success cases. [Implementation. ]
\begin{code}
pCatch (Pending state) k = do
  result <- readMVar state
  case result of
    Left x -> k x
    Right x -> return $ resolve x
pCatch (Fulfilled x) k = return $ resolve x
pCatch (Rejected x) k = k x
\end{code}
\lit{pCatch} is dual to \lit{pThen} in that it is identical to a \lit{pThen} that operates on \lit{Promise}s with reversed semantics for which type argument represents success and which failure.

[runpromise as helper function]
\lit{pThen} and \lit{pCatch} both share the same central function of waiting, if necessary, for a \lit{Promise} to settle, then branching on whether the result was a success or a failure.  We can generalize this behavior by writing a single function that accepts arguments specifying what to do in either case.  The action to do in the case of success can depend on the particular value the promise resolved with, so it should be a function accepting values of type \lit p.[Name the parameter - code calls it \lit{yes}]  The overall result [of \lit{runPromise}] must be contained in the IO monad because we can only compute it with the side effect of waiting for the \lit{Promise}[this would flow easier if I named the parameter] to settle.  [yes should match the runPromise return value so :: p -> IO ?, no more restrictions on ? => :: p -> IO a ; no must match return types therefore :: f -> IO a]

\begin{code}
runPromise :: (p -> IO a) -> (f -> IO a) -> Promise f p -> IO a
runPromise yes no (Pending state) = do
  result <- readMVar state
  case result of
    Left x -> no x
    Right x -> yes x
runPromise yes _ (Fulfilled x) = yes x
runPromise _ no (Rejected x) = no x

\end{code}
[reimplement \lit{pThen}, \lit{pCatch} with \lit{runPromise}]
[\lit{runPromise} has the semantics of the two-arg form of JS \lit{then}]

[ \lit{pFinally} ]

[ \lit{await}; definition, why it's useful, why use the name ]

[ Functor, Applicative, Monad instances; addition to the type so they don't need to be in IO]
[ explanation for why partially applied instances (\lit{Promise f})]
To define a Monad instance for \lit{Promise f}, we begin with \lit{Functor} and \lit{Applicative} instances.  For \lit{Functor (Promise f)}, we must define \lit{fmap} with type \lit{(a -> b) -> Promise f a -> Promise f b}.  \lit{fmap} must accept a function, \lit g, and a \lit{Promise}, \lit{pr}, as input and apply the \lit g to the success value of \lit{pr} if there is such a value, to yield a new \lit{Promise} (\lit{fmap} will have no effect on a \lit{Promise} that fails; we wouldn't be able to apply \lit g to the failure value since it has the wrong type).  It is simple enough to run \lit{pr} and then either apply \lit g to the result on a success or not on a failure, like so:
\begin{code}
  fmap' :: (a - > b) -> Promise f a -> IO (Promise f b)
  fmap' g pr = runPromise (return . resolve . g) (return . reject) pr
\end{code}
But we have a problem: computing \lit{fmap'} has a side effect - it waits until \lit{pr} has settled.  This side effect shows up in the type as we can see that \lit{fmap'} generates an \lit{IO (Promise f b)} instead of a \lit{Promise f b}.  To declare a \lit{Functor} instance, the type of \lit{fmap} is specified exaclty.  \lit{fmap'} isn't good enough  - \lit{Functor}s can be mapped over anywhere, not just inside the IO monad.  What we can do instead is store \lit g, so we can wait to apply it until we \emph{are} instructed to run \lit{pr}.  We can store \lit g by defining another constructor for \lit{Promise f p}.  We now know that there is another way to make a \lit{Promise} object: take an existing \lit{Promise} and store along with it a function to map over it.  We add a new line to the \lit{Promise} GADT, which now reads:
\begin{code}
data Promise :: * -> * -> * where
    Pending :: MVar (Either f p) -> Promise f p
    Fulfilled :: p -> Promise f p
    Rejected :: f -> Promise f p
    PromiseMap :: (a -> b) -> Promise f a -> Promise f b
\end{code}

At this point declaring the instance is as simple as telling Haskell to convert \lit{fmap} to our \lit{PromiseMap} constructor:
\begin{code}
instance Functor (Promise f) where
    fmap g pr = PromiseMap g pr
\end{code}
[If that seemed too easy, that's because it was; we still don't have anything like \lit{fmap'} to actually apply \lit g when it needs to be applied.]  Our definition for \lit{runPromise} needs to say what to do when we try to run a \lit{PromiseMap}.  [The pattern matching here looks like \lit{runPromise yes no (PromiseMap g pr)} ]Unlike when defining \lit{fmap}, at this point, we are returning an \lit{IO Promise} so we can wait for the contained promise \lit{pr} to settle and decide whether or not to apply \lit g.  We can make a recursive call to \lit{runPromise} on \lit{pr}; we know this will terminate becuase \lit{pr} is structurally smaller than \lit{PromiseMap g pr}[, so we're fine unless we're trying to run a \lit{Promise} with an infinite number of functions mapped over it ].  The \lit{no} function is unchanged since mapping over a failed \lit{Promise} has no effect, but in the case of a successful one, we need to call \lit g before we give the result to \lit{yes}.  This means the success function for the recursive call will be \lit{yes . g}, the composition of \lit{yes} and \lit g, that applies \lit g, then gives the result directly to \lit{yes}.
\begin{code}
runPromise yes no (PromiseMap g pr) = runPromise (yes . g) no pr
\end{code}

[ Proofs of typeclass laws (maybe put this elsewhere?) ]

The Javascript standard library has several ways to combine promises in parallel in addition to the sequential combination provided by \lit{then} and \lit{catch}.

[first describe implementation for pRace2 - it's simpler]
[JS provides \lit{Promise.race(iterable)}], which runs all of the input promises simultaneously in different threads, settling with the result of whichever completes first.  In our system this should have type signature \lit{pRace :: [Promise f p] -> IO (Promise f p)}.  To implement this function, let's begin with a binary variant that works for exactly two promises.  \lit{pRace2 :: Promise f p -> Promise f p -> IO (Promise f p)}.  [similar to \lit {amb} from [cite Push-Pull FRP]]  We can use an \lit{MVar} to accept a result from the first thread to finish.  Since we must differentiate between whether the result is a success or failure, we want the \lit{MVar} to hold an {Either f p}.  We create an empty MVar, then fork off a pair of threads, each of which runs one of the input promises and writes the result to the MVar.  Next, \lit{takeMVar} waits for either thread to finish and give it a result, after which we can kill both threads since they are no longer needed.
[insert pRace2 code here]

The \(n\)-ary version of \lit{pRace} operates by a sort of monadic fold over the list of input promises: we \lit{pRace2} the first promise in the list against the result of \lit{pRace}ing the rest of the list, with the result that we will settle to whichever out of any of the inputs settles first.  The Javascript standard specifies that \lit{race()}ing an empty iterable returns a forever-pending promise that never resolves or rejects.  This is convenient for our implementation because such a promise is the identity for \lit{pRace2} so we can use it directly as the base case to our fold.  We can generate an eternally pending promise by passing \lit{newPromise} a function that fails to call either the success or failure handle, like so: \verb|newPromise (\s f -> return ())|, so the final \lit{pRace} function is as follows:
[...]

[implementation of JS's Promise.any(iterable)] Javascript's promise API also provides \lit{.any(iterable)}, a different way to combine any number of promises in parallel by executing each simultaneously.  The result is a promise that immediately resolves to the value of the first input promise to successfully complete.  If all of the given promises fail, it gives a list of every failure value.  To implement this, let's again start with a binary version that combines exactly two promises in this way.  [ type signature \lit{pAny2 :: Promise f p -> Promise f' p -> IO (Promise (f, f') p)} ] [Note that this type signature is slightly more general than will be allowed by the \(n\)-ary version; in particular, the failure types of the two Promises can be different here, where in \lit{pAny} they will need to be the same so they can be contained in the same Haskell list.]  We still need an MVar to store the value of a success from either promise A or promise B, but dealing with a failure is somewhat more complicated since one failure isn't enough to end the computation, but we still need to track it so that we know to end if both branches end in failure. [need communication between the forked threads that doesn't interfere with the MVar holding successful results, => second \lit{MVar} that the main thread doesn't touch at all.  One fork writes to the error MVar, while the other waits to read from it after completion.]

[\lit{pAll2} and \lit{pAll} are dual to \lit{pAny2} and \lit{pAny}; we can implement by using \lit{PromiseInvert} to switch the true and false cases of the input promises, then switching back after running them through the dual function.]

\section{Comparison with Existing Concurrency Frameworks}
[Compare to push-pull frp]
[locks]

\section{Future Work}

[decouple Promise monad from IO ?]

\end{document}
